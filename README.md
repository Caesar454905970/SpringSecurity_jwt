## 登录认证

用户名密码加密存储进入数据库：

```
BCryptPasswordEncoder 加密解密实现
```



用户登录进入系统接口：

```
获取用户名密码+解密，重写UserDetailsService方法通过验证数据库中的用户名密码；


如果密码正确，根据userid生成token,发送给前端进行存储,并把userid:用户信息，这样的键值对存入redis池;


```

用户进行其他请求时，携带token

```
认证过滤器：后端接受到前端传递的token,对token里面解析出来是userid;使用userid去redis中获取对应的用户信息LoginUser对象，
redis对象存在,证明当前用户存在，并且已经登录，放行请求；不存在禁止访问当前请求接口

```



用户注销

```
后盾根据SecurityContextHolder中的认证信息（类似于gin中的上下文)，可以直接获取userid,操作redis池，删除对应的userid键值对
```


### 授权

每个接口都有限制访问资源所需权限

使用rbac权限模型来存储每个用户拥有的权限，

```
用户表--角色表：多对多中间表

角色表--权限表：多对多中间表

通过用户id，多表联查，查出改用户拥有的权限列表[]
```

未登录的用户：用户登录时，用户密码验证数据库通过，生成的用户对象存在SecurityContextHolder中，同时把userid和权限列表[]存入redis缓存中（留给该用户请求其他接口时进行验证）；



已经登录的用户：发起对应接口的请求，查询redis中改用户的权限与当前接口权限比较，如果拥有，就通过；没有就返回权限不足进行拦截
